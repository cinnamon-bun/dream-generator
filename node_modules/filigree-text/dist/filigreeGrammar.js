"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Generated automatically by nearley, version 2.16.0
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
let moo = require('moo');
let lexer = moo.compile({
    ruleName: /[a-zA-Z0-9_-]+/,
    eq: " = ",
    lbrak: "[",
    rbrak: "]",
    lang: "<",
    rang: ">",
    or: "/",
    dot: ".",
    // ignorable noise between lines:
    // optional whitespace
    // optional comment to the end of the line (starting with "#")
    // a required newline
    // optional whitespace starting the next line
    // This assumes the string ends in a newline!  You must ensure that's the case
    // (The Filigree class adds a newline at the end for you)
    nl: { match: /[ \t]*(?:#[^\n]*)?\n[ \t]*/, lineBreaks: true },
    // general string characters
    nonControlChars: /[^[/\]<.>=\n]/,
});
let flatten = (arr) => {
    let result = [];
    for (let item of arr) {
        if (Array.isArray(item)) {
            result = result.concat(flatten(item));
        }
        else {
            result.push(item);
        }
    }
    return result;
};
;
;
;
exports.Lexer = lexer;
exports.ParserRules = [
    { "name": "ruleDecls$ebnf$1", "symbols": [] },
    { "name": "ruleDecls$ebnf$1", "symbols": ["ruleDecls$ebnf$1", (lexer.has("nl") ? { type: "nl" } : nl)], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "ruleDecls$ebnf$2", "symbols": [] },
    { "name": "ruleDecls$ebnf$2$subexpression$1$ebnf$1", "symbols": [] },
    { "name": "ruleDecls$ebnf$2$subexpression$1$ebnf$1", "symbols": ["ruleDecls$ebnf$2$subexpression$1$ebnf$1", (lexer.has("nl") ? { type: "nl" } : nl)], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "ruleDecls$ebnf$2$subexpression$1", "symbols": ["ruleDecl", "ruleDecls$ebnf$2$subexpression$1$ebnf$1"] },
    { "name": "ruleDecls$ebnf$2", "symbols": ["ruleDecls$ebnf$2", "ruleDecls$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "ruleDecls", "symbols": ["ruleDecls$ebnf$1", "ruleDecls$ebnf$2"], "postprocess": ([nl, pairs]) => {
            return flatten(pairs).filter((x) => x.type !== 'nl');
        } },
    { "name": "ruleDecl", "symbols": [(lexer.has("ruleName") ? { type: "ruleName" } : ruleName), { "literal": " = " }, "seq"], "postprocess": ([ruleName, _, seq]) => ({
            id: -1,
            kind: 'decl',
            name: ruleName.value,
            value: seq,
        }) },
    { "name": "seq$ebnf$1", "symbols": ["literal"], "postprocess": id },
    { "name": "seq$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "seq$ebnf$2", "symbols": [] },
    { "name": "seq$ebnf$2$subexpression$1$ebnf$1", "symbols": ["literal"], "postprocess": id },
    { "name": "seq$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "seq$ebnf$2$subexpression$1", "symbols": ["tool", "seq$ebnf$2$subexpression$1$ebnf$1"] },
    { "name": "seq$ebnf$2", "symbols": ["seq$ebnf$2", "seq$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "seq", "symbols": ["seq$ebnf$1", "seq$ebnf$2"], "postprocess": ([firstLiteral, pairs]) => {
            // pairs is an array of [[tool], literal]
            // the literals are null if not present
            let sequence = [firstLiteral];
            for (let pair of pairs) {
                sequence.push(pair[0][0]);
                sequence.push(pair[1]);
            }
            return {
                id: -1,
                kind: 'seq',
                children: sequence.filter(x => x !== null),
            };
        } },
    { "name": "tool", "symbols": ["ref"] },
    { "name": "tool", "symbols": ["chooseMultiLine"] },
    { "name": "tool", "symbols": ["chooseOneLine"] },
    { "name": "ref$ebnf$1", "symbols": [] },
    { "name": "ref$ebnf$1$subexpression$1", "symbols": [(lexer.has("dot") ? { type: "dot" } : dot), (lexer.has("ruleName") ? { type: "ruleName" } : ruleName)] },
    { "name": "ref$ebnf$1", "symbols": ["ref$ebnf$1", "ref$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "ref", "symbols": [{ "literal": "<" }, (lexer.has("ruleName") ? { type: "ruleName" } : ruleName), "ref$ebnf$1", { "literal": ">" }], "postprocess": (parts) => {
            parts = flatten(parts);
            parts = parts.slice(1, parts.length - 1); // remove < and >
            let name = parts.shift().value;
            let mods = [];
            while (parts.length > 0) {
                let mod = parts.shift();
                if (mod.type !== 'dot') {
                    mods.push(mod.value);
                }
            }
            return {
                id: -1,
                kind: 'ref',
                name: name,
                mods: mods,
            };
        } },
    { "name": "chooseMultiLine$ebnf$1", "symbols": [] },
    { "name": "chooseMultiLine$ebnf$1$subexpression$1", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl), "seq"] },
    { "name": "chooseMultiLine$ebnf$1", "symbols": ["chooseMultiLine$ebnf$1", "chooseMultiLine$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "chooseMultiLine", "symbols": [{ "literal": "[" }, (lexer.has("nl") ? { type: "nl" } : nl), "seq", "chooseMultiLine$ebnf$1", (lexer.has("nl") ? { type: "nl" } : nl), { "literal": "]" }], "postprocess": (parts) => {
            let children = flatten(parts);
            //console.log('----------------\\');
            //console.log(JSON.stringify(children, null, 4));
            children = children.filter(child => child !== null && child.type !== 'lbrak' && child.type !== 'nl' && child.type !== 'rbrak');
            // remove empty lines
            children = children.filter(child => !(child.kind === 'seq' && child.children.length === 0)
            //&& ! (child.kind === 'seq' && child.children.length === 1 && child.children[0]
            );
            //console.log('----------------');
            //console.log(JSON.stringify(children, null, 4));
            //console.log('----------------/');
            return {
                id: -1,
                kind: 'choose',
                children: children,
            };
        } },
    { "name": "chooseOneLine$ebnf$1", "symbols": [] },
    { "name": "chooseOneLine$ebnf$1$subexpression$1", "symbols": [(lexer.has("or") ? { type: "or" } : or), "seq"] },
    { "name": "chooseOneLine$ebnf$1", "symbols": ["chooseOneLine$ebnf$1", "chooseOneLine$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "chooseOneLine", "symbols": [{ "literal": "[" }, "seq", "chooseOneLine$ebnf$1", { "literal": "]" }], "postprocess": (parts) => {
            let children = flatten(parts);
            children = children.filter(child => child.type !== 'lbrak' && child.type !== 'or' && child.type !== 'rbrak');
            return {
                id: -1,
                kind: 'choose',
                children: children,
            };
        } },
    { "name": "literal$ebnf$1$subexpression$1", "symbols": [(lexer.has("ruleName") ? { type: "ruleName" } : ruleName)] },
    { "name": "literal$ebnf$1$subexpression$1", "symbols": [(lexer.has("dot") ? { type: "dot" } : dot)] },
    { "name": "literal$ebnf$1$subexpression$1", "symbols": [(lexer.has("nonControlChars") ? { type: "nonControlChars" } : nonControlChars)] },
    { "name": "literal$ebnf$1", "symbols": ["literal$ebnf$1$subexpression$1"] },
    { "name": "literal$ebnf$1$subexpression$2", "symbols": [(lexer.has("ruleName") ? { type: "ruleName" } : ruleName)] },
    { "name": "literal$ebnf$1$subexpression$2", "symbols": [(lexer.has("dot") ? { type: "dot" } : dot)] },
    { "name": "literal$ebnf$1$subexpression$2", "symbols": [(lexer.has("nonControlChars") ? { type: "nonControlChars" } : nonControlChars)] },
    { "name": "literal$ebnf$1", "symbols": ["literal$ebnf$1", "literal$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "literal", "symbols": ["literal$ebnf$1"], "postprocess": (pieces) => {
            let text = pieces[0].map((p) => p[0].value).join('');
            return {
                id: -1,
                kind: 'literal',
                text: text
            };
        } }
];
exports.ParserStart = "ruleDecls";
