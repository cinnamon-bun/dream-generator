"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const nearley_1 = __importDefault(require("nearley"));
const seedrandom_1 = __importDefault(require("seedrandom"));
const filigreeGrammar = __importStar(require("./filigreeGrammar"));
const modifiers_1 = require("./modifiers");
//--------------------------------------------------------------------------------
// HELPERS
// return an array [0, 1, ..., n-1]
let range = (n) => [...Array(n).keys()];
let choose = (items) => items[Math.floor(Math.random() * items.length)];
let detChoose = (items, rng) => items[Math.floor(rng() * items.length)];
// inclusive integer range
let rngRange = (rng, min, max) => {
    let max1 = max + 1;
    return Math.floor(rng() * (max1 - min) + min);
};
// choose a random item from the front 60% of the array, move it to the back, then return the item
let detChooseAndMoveToBack = (items, rng) => {
    let ii;
    if (items.length <= 1) {
        return items[0];
    }
    else if (items.length === 2) {
        ii = Math.floor(rng() * 1.2); // usually the first one, but not always
    }
    else {
        // choose from the first 60% of the array, rounded up
        let countToConsider = Math.max(1, Math.ceil((items.length - 1) * 0.6));
        ii = rngRange(rng, 0, countToConsider - 1);
    }
    let item = items[ii];
    items.splice(ii, 1);
    items.push(item);
    return item;
};
// shuffle in place
let detShuffleArray = (items, idFn, rng) => {
    // TODO: sort by deterministic key of item which includes all its children
    items.sort((a, b) => idFn(a) - idFn(b));
    for (let ii = 0; ii < items.length - 1; ii++) {
        let kk = rngRange(rng, ii, items.length - 1);
        let temp = items[ii];
        items[ii] = items[kk];
        items[kk] = temp;
    }
};
let dedupeStrings = (arr) => {
    // given an array of strings, return a new array with duplicates removed
    let obj = {};
    for (let item of arr) {
        obj[item] = true;
    }
    return Object.keys(obj);
};
let flatten = (arr) => {
    let result = [];
    for (let item of arr) {
        if (Array.isArray(item)) {
            result = result.concat(flatten(item));
        }
        else {
            result.push(item);
        }
    }
    return result;
};
//--------------------------------------------------------------------------------
// Given a raw FExpr object, clean it up and remove redundant parts
let optimizeExprs = (expr) => {
    // recurse to children
    if (expr.kind === 'seq' || expr.kind === 'choose') {
        expr.children = expr.children.map(optimizeExprs);
    }
    // TODO: if seq has empty literals, remove them
    // convert two-char "\\n" to actual one-char "\n"
    if (expr.kind === 'literal') {
        expr.text = expr.text.split('\\n').join('\n');
    }
    // if seq or choose has only one child, return that child instead
    if ((expr.kind === 'seq' || expr.kind === 'choose') && expr.children.length === 1) {
        return expr.children[0];
    }
    // convert seq or choose with no children into an empty literal
    if ((expr.kind === 'seq' || expr.kind === 'choose') && expr.children.length === 0) {
        return {
            kind: 'literal',
            text: '',
        };
    }
    return expr;
};
// recursively assign unique ids to the exprs in sequence
let assignIds = (expr, idBox) => {
    expr.id = idBox[0];
    idBox[0] += 1;
    if (expr.kind === 'seq' || expr.kind === 'choose') {
        expr.children.forEach(ch => assignIds(ch, idBox));
    }
};
// Randomly shuffle the children of all the choice exprs, recursively
let shuffleChoices = (expr, rng) => {
    if (expr.kind === 'choose') {
        let sortFn = (x) => x.id;
        detShuffleArray(expr.children, sortFn, rng);
    }
    if (expr.kind === 'seq' || expr.kind === 'choose') {
        expr.children.forEach(ch => shuffleChoices(ch, rng));
    }
};
class Filigree {
    // Create a Filigree generator (a set of rules) from a Filigree-language source file.
    // source is a string of rules in Filigree format
    // If parsing fails, no error will be thrown, but this.err will become non-null
    // (and will contain an error message about what's wrong with the Filigree-language input).
    constructor(source, seed) {
        this.rules = {};
        this.err = null;
        this.modifiers = modifiers_1.makeModifiers();
        let parser = new nearley_1.default.Parser(nearley_1.default.Grammar.fromCompiled(filigreeGrammar));
        try {
            // add '\n' to ensure a comment on the last line lexes correctly
            let decls = parser.feed(source + '\n').results[0];
            for (let decl of decls) {
                this.rules[decl.name] = decl.value;
            }
            // TODO: warn if a rule is declared twice
        }
        catch (e) {
            this.err = e;
        }
        let idBox = [0];
        for (let name of this.ruleNames()) {
            this.rules[name] = optimizeExprs(this.rules[name]);
            assignIds(this.rules[name], idBox);
        }
        this.seed(seed);
    }
    seed(seed) {
        // omit seed to get a different random one each time
        this.rng = seedrandom_1.default(seed);
        for (let name of this.ruleNames()) {
            shuffleChoices(this.rules[name], this.rng);
        }
    }
    ruleNames() {
        return Object.keys(this.rules);
    }
    refsInRule(ruleName) {
        // return a list of the rules referenced by the given rule
        let refsInExpr = (expr) => {
            if (expr.kind === 'ref') {
                return [expr.name];
            }
            else if (expr.kind === 'seq' || expr.kind === 'choose') {
                return dedupeStrings(flatten(expr.children.map(refsInExpr)));
            }
            else {
                return [];
            }
        };
        return refsInExpr(this.rules[ruleName]);
    }
    // Generate text from a rule.
    // name is a rule name
    generate(name, wrapperFn) {
        if (this.rules[name] === undefined) {
            return '<' + name + '>'; // name not found
        }
        let result = this._evalFExpr(this.rules[name], wrapperFn);
        if (wrapperFn !== undefined) {
            result = wrapperFn(name, result);
        }
        return result;
    }
    // Evaluate a Filigree expression object
    _evalFExpr(expr, wrapperFn) {
        let result = '????';
        if (expr.kind == 'seq') {
            result = expr.children.map(ch => this._evalFExpr(ch, wrapperFn)).join('');
        }
        else if (expr.kind === 'ref') {
            let x = this.rules[expr.name];
            if (x === undefined) {
                // rule name not found
                return this._toStringFExpr(expr);
            }
            else {
                // TODO: test for stack overflow
                result = this._evalFExpr(x, wrapperFn);
                for (let modName of expr.mods) {
                    let modFn = this.modifiers[modName];
                    if (modFn === undefined) {
                        // modifier not found
                        return this._toStringFExpr(expr);
                    }
                    result = modFn(result);
                }
                if (wrapperFn !== undefined) {
                    result = wrapperFn(expr.name, result);
                }
            }
        }
        else if (expr.kind == 'choose') {
            result = this._evalFExpr(detChooseAndMoveToBack(expr.children, this.rng), wrapperFn);
        }
        else if (expr.kind === 'literal') {
            result = expr.text;
        }
        return result;
    }
    // Convert this set of Filigree rules back into Filigree language.
    toString() {
        return this._renderRules(this._toStringFExpr.bind(this));
    }
    // Show this set of Filigree rules in a debugging format
    repr() {
        return this._renderRules(this._reprFExpr.bind(this));
    }
    _renderRules(fn) {
        let result = [];
        for (let name of this.ruleNames()) {
            result.push(name + ' = ' + fn(this.rules[name]));
        }
        return result.join('\n');
    }
    // Convert back into filigree source code
    _toStringFExpr(expr) {
        let result = '????';
        if (expr.kind == 'seq') {
            result = expr.children.map(ch => this._toStringFExpr(ch)).join('');
        }
        else if (expr.kind === 'ref') {
            let mods = expr.mods.join('.');
            if (mods) {
                mods = '.' + mods;
            }
            result = '<' + expr.name + mods + '>';
        }
        else if (expr.kind == 'choose') {
            result = '[' + expr.children.map(ch => this._toStringFExpr(ch)).join('/') + ']';
        }
        else if (expr.kind === 'literal') {
            result = expr.text;
        }
        return result;
    }
    // Convert back into filigree source code but with extra notation to help understand the parsing
    _reprFExpr(expr) {
        let result = '????';
        if (expr.kind == 'seq') {
            result = '(' + expr.children.map(ch => this._reprFExpr(ch)).join('+') + ')';
        }
        else if (expr.kind === 'ref') {
            let mods = expr.mods.join('.');
            if (mods) {
                mods = '.' + mods;
            }
            result = '<' + expr.name + mods + '>';
        }
        else if (expr.kind == 'choose') {
            result = '[' + expr.children.map(ch => this._reprFExpr(ch)).join('/') + ']';
        }
        else if (expr.kind === 'literal') {
            result = '"' + expr.text + '"';
        }
        return result;
    }
}
exports.Filigree = Filigree;
